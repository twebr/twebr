{"version":3,"sources":["typed2.js"],"names":["$","Typed","el","options","this","extend","fn","typed","defaults","isInput","is","attr","showCursor","elContent","text","contentType","typeSpeed","startDelay","backSpeed","backDelay","strings","strPos","arrayPos","stopNum","loop","loopCount","curLoop","stop","backspacing","cursorChar","build","prototype","constructor","init","self","timeout","setTimeout","backspace","typewrite","cursor","after","curString","curStrPos","humanize","Math","round","random","charPause","substr","charAt","skip","test","exec","length","parseInt","substring","tag","onStringTyped","callback","preStringTyped","nextString","html","pauseTyping","console","log","clearInterval","continueTyping","reset","id","remove","resetCallback","option","each","$this","data","window","jQuery"],"mappings":"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","file":"typed2.min.js","sourcesContent":["// The MIT License (MIT)\n\n// Typed.js | Copyright (c) 2014 Matt Boldt | www.mattboldt.com\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n! function($) {\n\n    \"use strict\";\n\n    var Typed = function(el, options) {\n\n        // chosen element to manipulate text\n        this.el = $(el);\n\n        // options\n        this.options = $.extend({}, $.fn.typed.defaults, options);\n\n        // attribute to type into\n        this.isInput = this.el.is('input');\n        this.attr = this.options.attr;\n\n        // show cursor\n        this.showCursor = this.isInput ? false : this.options.showCursor;\n\n        // text content of element\n        this.elContent = this.attr ? this.el.attr(this.attr) : this.el.text()\n\n        // html or plain text\n        this.contentType = this.options.contentType;\n\n        // typing speed\n        this.typeSpeed = this.options.typeSpeed;\n\n        // add a delay before typing starts\n        this.startDelay = this.options.startDelay;\n\n        // backspacing speed\n        this.backSpeed = this.options.backSpeed;\n\n        // amount of time to wait before backspacing\n        this.backDelay = this.options.backDelay;\n\n        // input strings of text\n        this.strings = this.options.strings;\n\n        // character number position of current string\n        this.strPos = 0;\n\n        // current array position\n        this.arrayPos = 0;\n\n        // number to stop backspacing on.\n        // default 0, can change depending on how many chars\n        // you want to remove at the time\n        this.stopNum = 0;\n\n        // Looping logic\n        this.loop = this.options.loop;\n        this.loopCount = this.options.loopCount;\n        this.curLoop = 0;\n\n        // for stopping\n        this.stop = false;\n\n        // for pausing and continuing\n        this.backspacing = false;\n\n        // custom cursor\n        this.cursorChar = this.options.cursorChar;\n\n        // All systems go!\n        this.build();\n    };\n\n    Typed.prototype = {\n\n        constructor: Typed\n\n        ,\n        init: function() {\n            // begin the loop w/ first current string (global self.string)\n            // current string will be passed as an argument each time after this\n            var self = this;\n            self.timeout = setTimeout(function() {\n                // Start typing\n                if (self.backspacing) {\n                    self.backspace(self.strings[self.arrayPos], self.strPos);\n                } else {\n                    self.typewrite(self.strings[self.arrayPos], self.strPos);\n                }\n            }, self.startDelay);\n        }\n\n        ,\n        build: function() {\n            // Insert cursor\n            if (this.showCursor === true) {\n                this.cursor = $(\"<span class=\\\"typed-cursor\\\">\" + this.cursorChar + \"</span>\");\n                this.el.after(this.cursor);\n            }\n            this.init();\n        }\n\n        // pass current string state to each function, types 1 char per call\n        ,\n        typewrite: function(curString, curStrPos) {\n            // exit when stopped\n            if (this.stop === true) {\n                return;\n            }\n\n            // varying values for setTimeout during typing\n            // can't be global since number changes each time loop is executed\n            var humanize = Math.round(Math.random() * (100 - 30)) + this.typeSpeed;\n            var self = this;\n\n            // Needed for pausing\n            self.strPos = curStrPos;\n            self.backspacing = false;\n\n            // ------------- optional ------------- //\n            // backpaces a certain string faster\n            // ------------------------------------ //\n            // if (self.arrayPos == 1){\n            //  self.backDelay = 50;\n            // }\n            // else{ self.backDelay = 500; }\n\n            // contain typing function in a timeout humanize'd delay\n            self.timeout = setTimeout(function() {\n                // check for an escape character before a pause value\n                // format: \\^\\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^\n                // single ^ are removed from string\n                var charPause = 0;\n                var substr = curString.substr(curStrPos);\n                if (substr.charAt(0) === '^') {\n                    var skip = 1; // skip atleast 1\n                    if (/^\\^\\d+/.test(substr)) {\n                        substr = /\\d+/.exec(substr)[0];\n                        skip += substr.length;\n                        charPause = parseInt(substr);\n                    }\n\n                    // strip out the escape character and pause value so they're not printed\n                    curString = curString.substring(0, curStrPos) + curString.substring(curStrPos + skip);\n                }\n\n                if (self.contentType === 'html') {\n                    // skip over html tags while typing\n                    if (curString.substr(curStrPos).charAt(0) === '<') {\n                        var tag = '';\n                        while (curString.substr(curStrPos).charAt(0) !== '>') {\n                            tag += curString.substr(curStrPos).charAt(0);\n                            curStrPos++;\n                        }\n                        curStrPos++;\n                        tag += '>';\n                    }\n                }\n\n                // timeout for any pause after a character\n                self.timeout = setTimeout(function() {\n                    if (curStrPos === curString.length) {\n                        // fires callback function\n                        self.options.onStringTyped(self.arrayPos);\n\n                        // is this the final string\n                        if (self.arrayPos === self.strings.length - 1) {\n                            // animation that occurs on the last typed string\n                            self.options.callback();\n\n                            self.curLoop++;\n\n                            // quit if we wont loop back\n                            if (self.loop === false || self.curLoop === self.loopCount)\n                                return;\n                        }\n\n                        self.timeout = setTimeout(function() {\n                            self.backspace(curString, curStrPos);\n                        }, self.backDelay);\n                    } else {\n\n                        /* call before functions if applicable */\n                        if (curStrPos === 0)\n                            self.options.preStringTyped(self.arrayPos);\n\n                        // start typing each new char into existing string\n                        // curString: arg, self.el.html: original text inside element\n                        var nextString = self.elContent + curString.substr(0, curStrPos + 1);\n                        if (self.attr) {\n                            self.el.attr(self.attr, nextString);\n                        } else {\n                            if (self.contentType === 'html') {\n                                self.el.html(nextString);\n                            } else {\n                                self.el.text(nextString);\n                            }\n                        }\n\n                        // add characters one by one\n                        curStrPos++;\n                        // loop the function\n                        self.typewrite(curString, curStrPos);\n                    }\n                    // end of character pause\n                }, charPause);\n\n                // humanized value for typing\n            }, humanize);\n\n        }\n\n        ,\n        backspace: function(curString, curStrPos) {\n            // exit when stopped\n            if (this.stop === true) {\n                return;\n            }\n\n            // varying values for setTimeout during typing\n            // can't be global since number changes each time loop is executed\n            var humanize = Math.round(Math.random() * (100 - 30)) + this.backSpeed;\n            var self = this;\n\n            // Needed for pausing\n            self.strPos = curStrPos;\n            self.backspacing = true;\n\n            self.timeout = setTimeout(function() {\n\n                // ----- this part is optional ----- //\n                // check string array position\n                // on the first string, only delete one word\n                // the stopNum actually represents the amount of chars to\n                // keep in the current string. In my case it's 14.\n                // if (self.arrayPos == 1){\n                //  self.stopNum = 14;\n                // }\n                //every other time, delete the whole typed string\n                // else{\n                //  self.stopNum = 0;\n                // }\n\n                if (self.contentType === 'html') {\n                    // skip over html tags while backspacing\n                    if (curString.substr(curStrPos).charAt(0) === '>') {\n                        var tag = '';\n                        while (curString.substr(curStrPos).charAt(0) !== '<') {\n                            tag -= curString.substr(curStrPos).charAt(0);\n                            curStrPos--;\n                        }\n                        curStrPos--;\n                        tag += '<';\n                    }\n                }\n\n                // ----- continue important stuff ----- //\n                // replace text with base text + typed characters\n                var nextString = self.elContent + curString.substr(0, curStrPos);\n                if (self.attr) {\n                    self.el.attr(self.attr, nextString);\n                } else {\n                    if (self.contentType === 'html') {\n                        self.el.html(nextString);\n                    } else {\n                        self.el.text(nextString);\n                    }\n                }\n\n                // if the number (id of character in current string) is\n                // less than the stop number, keep going\n                if (curStrPos > self.stopNum) {\n                    // subtract characters one by one\n                    curStrPos--;\n                    // loop the function\n                    self.backspace(curString, curStrPos);\n                }\n                // if the stop number has been reached, increase\n                // array position to next string\n                else if (curStrPos <= self.stopNum) {\n                    self.arrayPos++;\n\n                    if (self.arrayPos === self.strings.length) {\n                        self.backspacing = false;\n                        self.arrayPos = 0;\n                        self.init();\n                    } else {\n                        self.typewrite(self.strings[self.arrayPos], curStrPos);\n                    }\n                }\n\n                // humanized value for typing\n            }, humanize);\n\n        }\n\n        ,\n        pauseTyping: function() {\n\n            console.log(\"typing paused\");\n\n            var self = this;\n\n            self.stop = true;\n            clearInterval(self.timeout);\n        }\n\n        ,\n        continueTyping: function() {\n\n\n            var self = this;\n\n            console.log(self.stop);\n\n            if(self.stop === false)\n               return;\n\n            this.stop = false;\n            this.init();\n        }\n\n        // Reset and rebuild the element\n        ,\n        reset: function() {\n            var self = this;\n            clearInterval(self.timeout);\n            var id = this.el.attr('id');\n            this.el.after('<span id=\"' + id + '\"/>')\n            this.el.remove();\n            this.cursor.remove();\n            // Send the callback\n            self.options.resetCallback();\n        }\n\n    };\n\n    $.fn.typed = function(option) {\n        return this.each(function() {\n            var $this = $(this),\n                data = $this.data('typed'),\n                options = typeof option == 'object' && option;\n            if (!data) $this.data('typed', (data = new Typed(this, options)));\n            if (typeof option == 'string') data[option]();\n        });\n    };\n\n    $.fn.typed.defaults = {\n        strings: [\"These are the default values...\", \"You know what you should do?\", \"Use your own!\", \"Have a great day!\"],\n        // typing speed\n        typeSpeed: 0,\n        // time before typing starts\n        startDelay: 0,\n        // backspacing speed\n        backSpeed: 0,\n        // time before backspacing\n        backDelay: 500,\n        // loop\n        loop: false,\n        // false = infinite\n        loopCount: false,\n        // show cursor\n        showCursor: true,\n        // character for cursor\n        cursorChar: \"|\",\n        // attribute to type (null == text)\n        attr: null,\n        // either html or text\n        contentType: 'html',\n        // call when done callback function\n        callback: function() {},\n        // starting callback function before each string\n        preStringTyped: function() {},\n        //callback for every typed string\n        onStringTyped: function() {},\n        // callback for reset\n        resetCallback: function() {}\n    };\n\n\n}(window.jQuery);\n"]}